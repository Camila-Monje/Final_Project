// Raspberry

import os
import cv2
import time
import serial
import numpy as np
from collections import Counter
from ultralytics import YOLO
from telegram import Update, Bot
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from telegram.request import HTTPXRequest

# === CONFIGURACI√ìN GLOBAL ===
TOKEN = '8027987269:AAHEzrXOv-IAYxBQ-xUtNjgXw7ul3-SOtnU'
CAPTURA_DIR = 'capturas_dead'
SERIAL_PORT = '/dev/ttyACM0'
BAUD_RATE = 115200

CLASSES = ['ripe', 'semi ripe', 'dead']
WAIT_SECONDS = 5
TIEMPO_RECORRIDO = 60

# === Inicializaci√≥n UART ===
try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
    print(f"[INFO] Conectado al puerto {SERIAL_PORT} a {BAUD_RATE} bps")
except serial.SerialException as e:
    print(f"[ERROR] No se pudo abrir el puerto: {e}")
    exit(1)

bot = Bot(token=TOKEN)
model = YOLO('/home/raspdcl/Proyecto Final/best.pt')

# === Inicializa la c√°mara ===
def inicializar_camara():
    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("No se pudo abrir la c√°mara")
        exit()
    return cap

# === Realiza la detecci√≥n con YOLO ===
def procesar_deteccion(frame):
    results = model.predict(source=frame, save=False, conf=0.3, verbose=False)
    names = model.names
    boxes = results[0].boxes
    labels = boxes.cls.cpu().numpy().astype(int) if boxes is not None else []
    clases_detectadas = [names[c] for c in labels if names[c] in CLASSES]
    return results[0], Counter(clases_detectadas)

def limpiar_directorio_dead():
    for archivo in os.listdir(CAPTURA_DIR):
        ruta_archivo = os.path.join(CAPTURA_DIR, archivo)
        try:
            os.remove(ruta_archivo)
            print(f"[INFO] Imagen eliminada: {ruta_archivo}")
        except Exception as e:
            print(f"[ERROR] No se pudo eliminar {ruta_archivo}: {e}")

# === Guarda im√°genes de frutillas muertas ===
def guardar_fotos_dead(frame, cantidad, contador_dead):
    for i in range(cantidad):
        nombre = f"dead_{contador_dead + i + 1}.jpg"
        ruta = os.path.join(CAPTURA_DIR, nombre)
        cv2.imwrite(ruta, frame)
    return contador_dead + cantidad

# === Recorre y detecta durante el recorrido ===
def recorrer_y_dibujar(cap):
    counted = {cls: 0 for cls in CLASSES}
    last_detection_time = {cls: 0 for cls in CLASSES}
    last_dead_save_time = 0
    dead_image_count = 0

    # Limpia carpeta de capturas
    if os.path.exists(CAPTURA_DIR):
        for f in os.listdir(CAPTURA_DIR):
            os.remove(os.path.join(CAPTURA_DIR, f))
    else:
        os.makedirs(CAPTURA_DIR)

    start_time = time.time()

    while time.time() - start_time < TIEMPO_RECORRIDO:
        ret, frame = cap.read()
        if not ret:
            print("Error al leer frame")
            break

        current_time = time.time()
        result, frame_counts = procesar_deteccion(frame)

        # === Guardar im√°genes de "dead"
        dead_count = frame_counts.get("dead", 0)
        if dead_count > 0 and (current_time - last_dead_save_time) >= WAIT_SECONDS:
            dead_image_count = guardar_fotos_dead(frame, dead_count, dead_image_count)
            last_dead_save_time = current_time

        # === Conteo simple cada WAIT_SECONDS
        for cls in CLASSES:
            if frame_counts.get(cls, 0) > 0 and (current_time - last_detection_time[cls]) >= WAIT_SECONDS:
                counted[cls] += 1
                last_detection_time[cls] = current_time

        # === Detecci√≥n de c√≠rculo azul
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        lower_blue = np.array([100, 150, 50])
        upper_blue = np.array([140, 255, 255])
        mask = cv2.inRange(hsv, lower_blue, upper_blue)
        blue_only = cv2.bitwise_and(frame, frame, mask=mask)
        gray = cv2.cvtColor(blue_only, cv2.COLOR_BGR2GRAY)
        gray = cv2.medianBlur(gray, 5)

        circles = cv2.HoughCircles(
            gray, cv2.HOUGH_GRADIENT, dp=1.2, minDist=30,
            param1=50, param2=30, minRadius=10, maxRadius=100
        )

        if circles is not None:
            ser.write(b"4\n")
            print("[INFO] C√≠rculo azul detectado ‚Üí enviado '4'")
            break

    return counted, dead_image_count

# === Env√≠a los resultados por Telegram ===
async def enviar_resultado_telegram(detection, cantidad_dead_imgs, update):
    msg = "Detecci√≥n final tras el recorrido:\n"
    msg += "\n".join([f"üîπ {k}: {v}" for k, v in detection.items()])

    try:
        await update.message.reply_text(msg, parse_mode="Markdown")
    except Exception as e:
        print(f"[ERROR] No se pudo enviar mensaje por Telegram: {e}")

    if cantidad_dead_imgs > 0:
        for i in range(cantidad_dead_imgs):
            ruta = os.path.join(CAPTURA_DIR, f"dead_{i + 1}.jpg")
            if os.path.exists(ruta):
                try:
                    with open(ruta, 'rb') as photo:
                        await update.message.reply_photo(photo=photo, caption="Frutilla muerta detectada")
                except Exception as e:
                    print(f"[ERROR] No se pudo enviar la imagen {ruta}: {e}")
    
    limpiar_directorio_dead()

# === Comandos de Telegram ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Bot conectado v√≠a UART.")
    print("[BOT] Comando /start recibido")

async def mover_adelante(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ser.write(b"2\n")
    await update.message.reply_text("‚û° Comenzando recorrido")
    print("[BOT] Comando /empezar_recorrido enviado: 2")

    cap = inicializar_camara()
    print("[INFO] Esperando 8 segundos antes de iniciar detecci√≥n...")
    time.sleep(8)
    conteo_final, cantidad_dead_imgs = recorrer_y_dibujar(cap)
    cap.release()
    await enviar_resultado_telegram(conteo_final, cantidad_dead_imgs, update)

async def mover_atras(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ser.write(b"3\n")
    await update.message.reply_text("‚¨Ö Inicio de riego")
    print("[BOT] Comando /riego enviado: 3")

async def detener(update: Update, context: ContextTypes.DEFAULT_TYPE):
    ser.write(b"S\n")
    await update.message.reply_text("Enviando comando: S")
    print("[BOT] Comando /stop enviado: S")

# === Main ===
def main():
    request = HTTPXRequest(connect_timeout=10.0, read_timeout=20.0)
    app = ApplicationBuilder().token(TOKEN).request(request).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("empezar_recorrido", mover_adelante))
    app.add_handler(CommandHandler("riego", mover_atras))
    app.add_handler(CommandHandler("stop", detener))
    print("Bot escuchando comandos...")
    app.run_polling()

if _name_ == "_main_":
    main()
